{"version":3,"sources":["../src/iso8601.ts","../src/date.ts","../src/addDay.ts","../src/monthEnd.ts","../src/monthDays.ts","../src/addMonth.ts","../src/addYear.ts","../src/addHour.ts","../src/addMinute.ts","../src/addSecond.ts","../src/common.ts","../src/ap.ts","../src/applyOffset.ts","../src/deviceTZ.ts","../src/offset.ts","../src/tzDate.ts","../src/dayOfYear.ts","../src/dayEnd.ts","../src/dayStart.ts","../src/parts.ts","../src/removeOffset.ts","../src/deviceLocale.ts","../src/format.ts","../src/formatStr.ts","../src/fourDigitYear.ts","../src/hourEnd.ts","../src/hourStart.ts","../src/minuteEnd.ts","../src/minuteStart.ts","../src/monthStart.ts","../src/yearDays.ts","../src/nearestDay.ts","../src/range.ts","../src/parse.ts","../src/sameDay.ts","../src/sameSecond.ts","../src/sameMinute.ts","../src/sameHour.ts","../src/sameYear.ts","../src/weekStart.ts","../src/weekEnd.ts","../src/yearStart.ts","../src/yearEnd.ts","../src/isBefore.ts","../src/isAfter.ts","../src/isEqual.ts"],"sourcesContent":["/**\n * Matches a given date with ISO 8601 compliance. Allows the \"T\" to be missing\n * and only requires year and month, other params are required with increasing\n * specificity.\n */\nexport const iso8601Match =\n  /^([0-9]{4})-([0-1][0-9])(?:-([0-3][0-9]))?(?:[T ]?([0-2][0-9])(?::([0-5][0-9]))?(?::([0-5][0-9]))?)?(?:\\.[0-9]+)?(Z|(?:\\+|\\-)[0-9]{2}:?[0-9]{2})?$/\n\n/**\n * True when the date string is valid ISO 8601.\n * @param date - A date string.\n */\nexport function iso8601(date: string): boolean {\n  const matches = date.match(iso8601Match)\n  if (matches) {\n    const month = Number(matches[2])\n    if (month < 1 || month > 12) return false\n\n    if (typeof matches[3] !== undefined) {\n      const date = Number(matches[3])\n      if (date < 1 || date > 31) return false\n    }\n    if (typeof matches[4] !== undefined) {\n      const hours = Number(matches[4])\n      if (hours < 0 || hours > 23) return false\n    }\n\n    return true\n  }\n  return false\n}\n","import { iso8601, iso8601Match } from \"./iso8601\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Normalizes a \"short\" date like 2012-01-01 to 2012-01-01T00:00:00 to prevent\n * automatic coercion to UTC.\n * @param date - A string representation of the date.\n */\nfunction normalize(date: string) {\n  const matches = date.match(iso8601Match)\n  if (matches && typeof matches[4] === \"undefined\") {\n    return (date += \"T00:00:00\")\n  }\n  return date\n}\n\n/**\n * A date to parse.\n * @param date - A Date object or an ISO 8601 date.\n */\nexport function date(date?: DateInput): Date {\n  if (!date) {\n    date = new Date()\n  }\n  if (date instanceof Date) {\n    const d = new Date(date)\n    d.setMilliseconds(0)\n    return d\n  }\n  date = date.trim()\n  if (iso8601(date)) {\n    return new Date(normalize(date))\n  }\n  throw new Error(`Non ISO 8601 compliant date (${date}).`)\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n days after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addDay(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setDate(d.getDate() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the last day of\n * the current month. Does not change the time.\n * @param inputDate - A string or Date object\n */\nexport function monthEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setDate(1)\n  d.setMonth(d.getMonth() + 1)\n  d.setDate(0)\n  return d\n}\n","import { monthEnd } from \"./monthEnd\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns the total number of days from a given month.\n * @param inputDate - A string or Date object\n */\nexport function monthDays(inputDate: DateInput): number {\n  const d = monthEnd(inputDate)\n  return d.getDate()\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n months after the original one. Keep in mind if you\n * start with a date late in a given month you could get a date after the next\n * month.\n * @param inputDate - A date to increment by 1 or more months.\n * @param count - The quantity to add.\n * @param dateOverflow - Whether or not to allow the date to overflow to another month if the inputDate’s month is out of range of the new month.\n */\nexport function addMonth(\n  inputDate: DateInput,\n  count = 1,\n  dateOverflow = false\n) {\n  const d = date(inputDate)\n  const dayOfMonth = d.getDate()\n  // If overflowing is disallowed, set the date back to the first of the month\n  if (!dateOverflow) d.setDate(1)\n  d.setMonth(d.getMonth() + count)\n\n  // If overflowing is disallowed, we need to set the date back to the proper\n  // day or the last day of the month.\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d)\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth)\n  }\n  return d\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n years after the original one. Keep in mind if\n * you start with a date late in a given month you could get a date after the\n * next month.\n * @param inputDate - A date to increment by 1 day.\n * @param count - The quantity of years add.\n * @param dateOverflow - Whether or not to allow the date to overflow to another month if the inputDate’s month is out of range of the new month.\n */\nexport function addYear(inputDate: DateInput, count = 1, dateOverflow = false) {\n  const d = date(inputDate)\n  const dayOfMonth = d.getDate()\n  // If overflowing is disallowed, set the date back to the first of the month\n  if (!dateOverflow) d.setDate(1)\n\n  d.setFullYear(d.getFullYear() + count)\n\n  // If overflowing is disallowed, we need to set the date back to the proper\n  // day or the last day of the month.\n  if (!dateOverflow) {\n    const daysInMonth = monthDays(d)\n    d.setDate(daysInMonth < dayOfMonth ? daysInMonth : dayOfMonth)\n  }\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n hours after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addHour(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setHours(d.getHours() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n seconds after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addMinute(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setMinutes(d.getMinutes() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a new date object 1/n seconds after the original one.\n * @param inputDate - A date to increment by 1 day.\n */\nexport function addSecond(inputDate: DateInput, count = 1) {\n  const d = date(inputDate)\n  d.setSeconds(d.getSeconds() + count)\n  return d\n}\n","import { date } from \"./date\"\nimport { ap } from \"./ap\"\nimport type {\n  DateInput,\n  NamedFormats,\n  FormatPattern,\n  FormatStyle,\n  Part,\n  FilledPart,\n} from \"./types\"\n\n/**\n * A date to use for determining various spec details.\n */\nexport const specDate = \"1999-03-04T02:05:01.000Z\"\n\n/**\n * A cache of Intl tokens and their respective formats.\n */\nexport const memoParts: Map<string, NamedFormats> = new Map()\n\n/**\n * Clock agnostic time format patterns.\n */\nexport const clockAgnostic: FormatPattern[] = [\n  [\"YYYY\", { year: \"numeric\" }],\n  [\"YY\", { year: \"2-digit\" }],\n  [\"MMMM\", { month: \"long\" }],\n  [\"MMM\", { month: \"short\" }],\n  [\"MM\", { month: \"2-digit\" }],\n  [\"M\", { month: \"numeric\" }],\n  [\"DD\", { day: \"2-digit\" }],\n  [\"D\", { day: \"numeric\" }],\n  [\"dddd\", { weekday: \"long\" }],\n  [\"ddd\", { weekday: \"short\" }],\n  [\"d\", { weekday: \"narrow\" }],\n  [\"mm\", { minute: \"2-digit\" }],\n  [\"m\", { minute: \"numeric\" }],\n  [\"ss\", { second: \"2-digit\" }],\n  [\"s\", { second: \"numeric\" }],\n  [\"Z\", { timeZoneName: \"short\" }],\n]\n\n/**\n * 24 hour click format patterns.\n */\nexport const clock24: FormatPattern[] = [\n  [\"HH\", { hour: \"2-digit\" }],\n  [\"H\", { hour: \"numeric\" }],\n]\n\n/**\n * 12 hour format patterns.\n */\nexport const clock12: FormatPattern[] = [\n  [\"hh\", { hour: \"2-digit\" }],\n  [\"h\", { hour: \"numeric\" }],\n  [\"a\", { dayPeriod: \"narrow\" }],\n  [\"A\", { dayPeriod: \"narrow\" }],\n]\n\n/**\n * Tokens that have a fixed length.\n */\nexport const fixedLength = {\n  DD: 2,\n  HH: 2,\n  MM: 2,\n  YY: 2,\n  YYYY: 4,\n  hh: 2,\n  mm: 2,\n  ss: 2,\n}\n\n/**\n * token Z can have variable length depending on the actual value, so it's\n */\nexport function fixedLengthByOffset(offsetString: string): number {\n  // starts with [+-]xx:xx\n  if (/^[+-]\\d{2}:\\d{2}/.test(offsetString)) {\n    return 6\n  }\n\n  // starts with [+-]xxxx\n  if (/^[+-]\\d{4}/.test(offsetString)) {\n    return 5\n  }\n\n  throw new Error(\"Invalid offset format\")\n}\n\n/**\n * Tokens that are genitive — in that they can have \"possession\" when used in\n * a date phrase, \"March’s 4th day\" (but not in english).\n *\n * When computing a range for these, the range can be either genitive or not.\n * The same is true for parsing dates containing these tokens.\n */\nexport const genitiveTokens = [\"MMMM\", \"MMM\", \"dddd\", \"ddd\"]\n\n/**\n * A map of FormatPattern tuples to their respective token.\n */\nexport const tokens = /* @__PURE__ */ new Map(\n  /* @__PURE__ */ [...clockAgnostic, ...clock24, ...clock12].map((format) => {\n    return [format[0], format]\n  })\n)\n\n/**\n * A map of locale’s am/pm.\n */\nexport const dayPeriodMap: Map<string, { am?: string; pm?: string }> = new Map()\n\n/**\n * An array of all available date styles.\n */\nexport const styles: ReadonlyArray<FormatStyle> = [\n  \"full\",\n  \"long\",\n  \"medium\",\n  \"short\",\n]\n\n/**\n * Creates a leading zero string of 2 digits.\n * @param n - A number.\n */\nexport const two = (n: number) => String(n).padStart(2, \"0\")\n/**\n * Creates a leading zero string of 4 digits.\n * @param n - A number.\n */\nexport const four = (n: number) => String(n).padStart(2, \"0\")\n\n/**\n * Normalizes a given part to NFKC.\n * @param part - The part to normalize.\n */\nexport function normStr(\n  part: Intl.DateTimeFormatPart\n): Intl.DateTimeFormatPart {\n  if (part.type === \"literal\") {\n    part.value = part.value.normalize(\"NFKC\")\n  }\n  return part\n}\n\n/**\n * Returns the parts filled with pertinent values.\n * @param inputDate - The date to fill parts for\n * @param parts - An array of parts to fill\n * @param locale - The locale to fill with.\n * @param genitive - Whether to use genitive tokens values or not.\n * @param offset - The explicit offset to fill with (ignores the date’s true offset).\n */\nexport function fill(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false,\n  offset: string | null = null\n): FilledPart[] {\n  const partMap = createPartMap(inputDate, parts, locale, genitive)\n  const d = date(inputDate)\n\n  /**\n   * Not all values get returned \"properly\" as our tokens would suggest. For\n   * example, at times Intl returns leading zeros when it shouldn't. This fn\n   * is used to clean up those irregular values.\n   * @param param - Part\n   */\n  function value({ partName, partValue, token }: Part) {\n    if (partName === \"literal\") return partValue\n    const value = partMap[partName]\n    if (partName === \"hour\" && token === \"H\") {\n      return value.replace(/^0/, \"\") || \"0\"\n    }\n    if ([\"mm\", \"ss\", \"MM\"].includes(token) && value.length === 1) {\n      // Some tokens are supposed to have leading zeros, but Intl doesn't\n      // always return them, depending on the locale and the format.\n      return `0${value}`\n    }\n    if (partName === \"dayPeriod\") {\n      const p = ap(d.getUTCHours() < 12 ? \"am\" : \"pm\", locale)\n      return token === \"A\" ? p.toUpperCase() : p.toLowerCase()\n    }\n    if (partName === \"timeZoneName\") {\n      return offset ?? minsToOffset(-1 * d.getTimezoneOffset())\n    }\n    return value\n  }\n\n  return parts.map((part): FilledPart => {\n    return {\n      ...part,\n      value: value(part),\n    }\n  })\n}\n\n/**\n * Creates a map of part names to their respective values.\n * @param inputDate - The date to format\n * @param parts - The individual parts the need to be formatted.\n * @param locale - The locale to format the parts with.\n * @param genitive - Whether to use genitive tokens values or not.\n */\nfunction createPartMap(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false\n): Record<keyof Intl.DateTimeFormatPartTypesRegistry, string> {\n  const d = date(inputDate)\n  const hour12 = parts.filter((part) => part.hour12)\n  const hour24 = parts.filter((part) => !part.hour12)\n  const valueParts: Intl.DateTimeFormatPart[] = []\n  const genitiveParts: Part[] = []\n\n  function addValues(requestedParts: Part[], hour12 = false) {\n    const preciseLocale = `${locale}-u-hc-${hour12 ? \"h12\" : \"h23\"}`\n    valueParts.push(\n      ...new Intl.DateTimeFormat(\n        preciseLocale,\n        requestedParts.reduce(\n          (options, part) => {\n            if (part.partName === \"literal\") return options\n            // Side effect! Genitive parts get shoved into a separate array.\n            if (genitive && genitiveTokens.includes(part.token)) {\n              genitiveParts.push(part)\n            }\n            return Object.assign(options, part.option)\n          },\n          { timeZone: \"UTC\" } as Intl.DateTimeFormatOptions\n        )\n      )\n        .formatToParts(d)\n        .map(normStr)\n    )\n    if (genitive && genitiveParts.length) {\n      for (const part of genitiveParts) {\n        let formattedParts: Intl.DateTimeFormatPart[] = []\n        switch (part.token) {\n          case \"MMMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"long\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n          case \"MMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"medium\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n        }\n        const genitiveFormattedPart = formattedParts.find(\n          (p) => p.type === part.partName\n        )\n        const index = valueParts.findIndex((p) => p.type === part.partName)\n        if (genitiveFormattedPart && index > -1) {\n          valueParts[index] = genitiveFormattedPart\n        }\n      }\n    }\n  }\n\n  if (hour12.length) addValues(hour12, true)\n  if (hour24.length) addValues(hour24)\n\n  return valueParts.reduce((map, part) => {\n    map[part.type] = part.value\n    return map\n  }, {} as Record<keyof Intl.DateTimeFormatPartTypesRegistry, string>)\n}\n\n/**\n * Converts minutes (300) to an ISO8601 compatible offset (+0400).\n * @param timeDiffInMins - The difference in minutes between two timezones.\n * @returns\n */\nexport function minsToOffset(timeDiffInMins: number): string {\n  const hours = String(Math.floor(Math.abs(timeDiffInMins / 60))).padStart(\n    2,\n    \"0\"\n  )\n  const mins = String(Math.abs(timeDiffInMins % 60)).padStart(2, \"0\")\n  const sign = timeDiffInMins < 0 ? \"-\" : \"+\"\n  return `${sign}${hours}${mins}`\n}\n\n/**\n * Converts an offset (-0500) to minutes (-300).\n * @param offset - The offset to convert to minutes.\n */\nexport function offsetToMins(offset: string): number {\n  validOffset(offset)\n  const [_, sign, hours, mins] = offset.match(/([+-])([0-3][0-9])([0-6][0-9])/)!\n  const offsetInMins = Number(hours) * 60 + Number(mins)\n  return sign === \"+\" ? offsetInMins : -offsetInMins\n}\n\n/**\n * Validates that an offset is valid according to the format:\n * [+-]HHmm or [+-]HH:mm\n * @param offset - The offset to validate.\n */\nexport function validOffset(offset: string) {\n  const valid = /^([+-])[0-3][0-9]:?[0-6][0-9]$/.test(offset)\n  if (!valid) throw new Error(`Invalid offset: ${offset}`)\n  return offset\n}\n\n/**\n * Given a string of tokens, escape any characters that are tokens.\n * @param str - The string to escape tokens in.\n * @returns The escaped string.\n */\nexport function escapeTokens(str: string): string {\n  return clockAgnostic\n    .concat(clock24)\n    .concat(clock12)\n    .sort((a, b) => (a[0].length > b[0].length ? 1 : -1))\n    .reduce((target, part) => {\n      return target.replace(part[0], `\\\\${part[0]}`)\n    }, str)\n}\n\n/**\n * Checks if a given part should have a numeric value.\n * @param part - A part to check\n */\nexport function isNumeric(part: Part) {\n  return [\"numeric\", \"2-digit\"].includes(part.partValue)\n}\n\n/**\n * Validates that an array of Parts can be parsed.\n * @param parts - Parts to validate for parsing ability.\n */\nexport function validate(parts: Part[]): Part[] | never {\n  let lastPart: Part | undefined = undefined\n  for (const part of parts) {\n    if (part.partName === \"literal\" && !isNaN(parseFloat(part.partValue))) {\n      throw new Error(`Numbers in format (${part.partValue}).`)\n    }\n    if (\n      lastPart &&\n      lastPart.partName !== \"literal\" &&\n      part.partName !== \"literal\"\n    ) {\n      if (\n        !(lastPart.token in fixedLength) &&\n        !(part.token in fixedLength) &&\n        !(isNumeric(lastPart) && part.token.toLowerCase() === \"a\")\n      ) {\n        throw new Error(\n          `Illegal adjacent tokens (${lastPart.token}, ${part.token})`\n        )\n      }\n    }\n    lastPart = part\n  }\n  return parts\n}\n","import { dayPeriodMap, specDate, normStr } from \"./common\"\n\n/**\n * Determines the correct value for am/pm by locale and memoizes it.\n * @param ampm - am or pm\n * @param locale - The locale to fetch.\n */\nexport function ap(ampm: \"am\" | \"pm\", locale: string): string {\n  const l = dayPeriodMap.get(locale)\n  if (l && l[ampm]) return l[ampm] as string\n  const specimen = new Date(specDate)\n  specimen.setUTCHours(ampm === \"am\" ? 5 : 20)\n  const subparts = new Intl.DateTimeFormat(locale, {\n    timeStyle: \"full\",\n    timeZone: \"UTC\",\n    hour12: true,\n  })\n    .formatToParts(specimen)\n    .map(normStr)\n  const period = subparts.find((part) => part.type === \"dayPeriod\")\n  if (period) {\n    const localePeriods: { am?: string; pm?: string } = l || {}\n    dayPeriodMap.set(\n      locale,\n      Object.assign(localePeriods, { [ampm]: period.value })\n    )\n    return period.value\n  }\n  return ampm\n}\n","import { date } from \"./date\"\nimport { offsetToMins } from \"./common\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Apply a given offset to a date, returning a new date with the offset\n * applied by adding or subtracting the given number of minutes.\n * @param dateInput - The date to apply the offset to.\n * @param offset - The offset to apply in the +-HHmm format.\n */\nexport function applyOffset(dateInput: DateInput, offset = \"+0000\"): Date {\n  const d = date(dateInput)\n  const timeDiffInMins = offsetToMins(offset)\n  return new Date(d.getTime() + timeDiffInMins * 1000 * 60)\n}\n","/**\n * Get the timezone of the device.\n *\n * * Note: If the environment variable TZ is not set, it will return undefined.\n */\nexport function deviceTZ(): string | undefined {\n  return Intl.DateTimeFormat().resolvedOptions().timeZone as string | undefined\n}\n","import { date } from \"./date\"\nimport { normStr, minsToOffset } from \"./common\"\nimport { deviceTZ } from \"./deviceTZ\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Converts a date object from one timezone to that same time in UTC. This is\n * only for internal use.\n * @param d - A Date object\n * @param timeZone - A timezone string\n */\nfunction relativeTime(d: Date, timeZone: string): Date {\n  const utcParts = new Intl.DateTimeFormat(\"en-US\", {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZone,\n    hourCycle: \"h23\",\n  })\n    .formatToParts(d)\n    .map(normStr)\n  const parts: {\n    year?: string\n    month?: string\n    day?: string\n    hour?: string\n    minute?: string\n    second?: string\n  } = {}\n  utcParts.forEach((part) => {\n    parts[part.type as keyof typeof parts] = part.value\n  })\n  return new Date(\n    `${parts.year}-${parts.month}-${parts.day}T${parts.hour}:${parts.minute}:${parts.second}Z`\n  )\n}\n\n/**\n * Returns the offset between two timezones on a given date. The results are\n * ISO8601 compatible offsets like -0800 or +0530.\n *\n * @param dateInput - The date on which to determine the offset.\n * @param tzA - (default: UTC) The second timezone to compare determine the offset between.\n * @param tzB - (default: device) The first timezone to compare determine the offset between.\n */\nexport function offset(\n  utcTime: DateInput,\n  tzA = \"UTC\",\n  tzB = \"device\"\n): string {\n  tzB = tzB === \"device\" ? deviceTZ() ?? \"utc\" : tzB\n  const d = date(utcTime)\n  const timeA = relativeTime(d, tzA)\n  const timeB = relativeTime(d, tzB)\n  const timeDiffInMins = (timeB.getTime() - timeA.getTime()) / 1000 / 60\n  return minsToOffset(timeDiffInMins)\n}\n","import { offset } from \"./offset\"\nimport { applyOffset } from \"./applyOffset\"\nimport { date } from \"./date\"\nimport { DateInput } from \"./types\"\n\n/**\n * Creates a date object for the input date at the given timezone. For example\n * `tzDate(\"2017-05-06T12:00\", \"Europe/Amsterdam\")` will return a date object\n * for 2017-05-06T10:00:00Z since 12:00 in Amsterdam is 10:00Z.\n *\n * If given a Date object it will use local time and convert it to the given\n * timezone, thus \"changing\" the date.\n * @param inputDate - An iso8601 date string with no timezone\n * @param tz - A timezone string\n */\nexport function tzDate(inputDate: DateInput, tz: string) {\n  const d = date(inputDate)\n  return applyOffset(d, offset(d, tz))\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Gets the what day of the year a given date is. For example, August 1st is\n * the 213th day of the year on non- years and 214th on leap years.\n * @param inputDate - The input date.\n */\nexport function dayOfYear(inputDate: DateInput): number {\n  const d = date(inputDate)\n  return Math.round(\n    (new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0).getTime() -\n      new Date(d.getFullYear(), 0, 0).getTime()) /\n      86400000\n  )\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given day.\n * @param inputDate - A string or Date object\n */\nexport function dayEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setHours(23, 59, 59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given day.\n * @param inputDate - A string or Date object\n */\nexport function dayStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import {\n  styles,\n  normStr,\n  tokens,\n  memoParts,\n  clockAgnostic,\n  clock24,\n  specDate,\n  clock12,\n} from \"./common\"\nimport type {\n  ParseOptions,\n  Format,\n  Part,\n  FormatStyle,\n  FormatStyleObj,\n  FormatPattern,\n  NamedFormats,\n  NamedFormatOption,\n} from \"./types\"\n/**\n * Given a format string, produce an array of matching \"parts\", each part\n * contains a regular expression and the corresponding\n * Intl.DateTimeFormatPartTypesRegistry key/value.\n * @param format - A format string like MM/DD/YYYY\n * @param locale - The locale to parse for.\n */\nexport function parts(format: Format, locale: string): Part[] {\n  if (styles.includes(format as FormatStyle) || typeof format === \"object\") {\n    return styleParts(format as FormatStyle | FormatStyleObj, locale)\n  }\n  let f = format\n  let match = 0\n  const testPattern = (pattern: FormatPattern) => {\n    if (!pattern[2]) pattern[2] = new RegExp(`(.)?(${pattern[0]})`, \"g\")\n    if (pattern[2].test(f)) {\n      let didAdd = 0\n      f = f.replace(pattern[2], (_, prefix, actualMatch) => {\n        if (prefix === \"\\\\\") return actualMatch\n        return `${typeof prefix === \"string\" ? prefix : \"\"}{!${\n          didAdd++ ? match : match++\n        }!}`\n      })\n      return !!didAdd\n    }\n    return false\n  }\n\n  function validate(patterns: Part[]): Part[] {\n    const parts = patterns.map((part) => part.partName)\n    const deduped = new Set(parts)\n    if (parts.length > deduped.size) {\n      throw new Error(`Cannot reuse format tokens.`)\n    }\n    return patterns\n  }\n\n  function createPart(\n    hour12: boolean,\n    [token, option, exp]: FormatPattern\n  ): Part {\n    const partName = Object.keys(option)[0] as Intl.DateTimeFormatPartTypes\n    const partValue = option[partName] as string\n    return {\n      option,\n      partName,\n      partValue,\n      token,\n      pattern: exp as RegExp,\n      hour12,\n    }\n  }\n\n  const found24Patterns = clockAgnostic\n    .filter(testPattern)\n    .concat(clock24.filter(testPattern))\n    .map(createPart.bind(null, false))\n\n  // Reset the format before re-checking\n  const parts = validate(\n    found24Patterns.concat(\n      clock12.filter(testPattern).map(createPart.bind(null, true))\n    )\n  )\n  const extractIndex = /^\\{!(\\d+)!\\}$/\n  return f\n    .split(/(\\{!\\d+!\\})/)\n    .map((match: string): Part => {\n      const hasIndex = match.match(extractIndex)\n      if (hasIndex) {\n        return parts[Number(hasIndex[1])]\n      }\n      return {\n        option: { literal: match },\n        partName: \"literal\",\n        partValue: match,\n        token: match,\n        pattern: new RegExp(\"\"),\n        hour12: false,\n      }\n    })\n    .filter((part) => !(part.partName === \"literal\" && part.partValue === \"\"))\n}\n\n/**\n * Determines the parts in a native date style, like \"full\".\n * @param format - A date style like \"full\" or \"short\"\n * @param locale - The locale string\n */\nfunction styleParts(\n  format: FormatStyle | FormatStyleObj,\n  locale: string\n): Part[] {\n  const options: Intl.DateTimeFormatOptions = {\n    timeZone: \"UTC\",\n  }\n  if (typeof format === \"string\") {\n    options.dateStyle = format\n  } else {\n    if (\"date\" in format) options.dateStyle = format.date\n    if (\"time\" in format) options.timeStyle = format.time\n  }\n\n  const formatter = new Intl.DateTimeFormat(locale, options)\n  const segments = formatter.formatToParts(new Date(specDate)).map(normStr)\n  const hourTypeSegments = formatter\n    .formatToParts(new Date(\"1999-04-05T23:05:01.000Z\"))\n    .map(normStr)\n  const hourPart = hourTypeSegments.find((segment) => segment.type === \"hour\")\n  const hourType = hourPart && hourPart.value === \"23\" ? 24 : 12\n  return segments\n    .map((part): Part | undefined => {\n      const partName = part.type\n      const formatPattern = guessPattern(\n        part.type,\n        part.value,\n        locale,\n        part.type === \"hour\" ? hourType : undefined\n      )\n      if (formatPattern === undefined) return\n      const partValue = formatPattern[1][partName]\n      if (!partValue) return\n      if (!formatPattern[2])\n        formatPattern[2] = new RegExp(`${formatPattern[0]}`, \"g\")\n      return {\n        option: { [partName]: partValue },\n        partName,\n        partValue,\n        token: formatPattern[0],\n        pattern: formatPattern[2],\n        hour12: hourType === 12,\n      }\n    })\n    .filter((part): part is Part => !!part)\n}\n\n/**\n * Attempts to guess the correct part value type for a given dateStyle. For\n * example a month of 02 would be \"2-digit\".\n *\n * @param partName - The part name to guess for, like 'year' or 'month'\n * @param partValue - The current value, it is assumed this is the smallest denom.\n */\nfunction guessPattern<T extends Intl.DateTimeFormatPartTypes>(\n  partName: T,\n  partValue: string,\n  locale: string,\n  hour: T extends \"hour\" ? 12 | 24 : undefined\n): FormatPattern | undefined {\n  const l = partValue.length\n  const n = !isNaN(Number(partValue))\n  let style: NamedFormatOption | undefined\n  /* eslint-disable @typescript-eslint/no-non-null-assertion */\n  switch (partName) {\n    case \"year\":\n      return l === 2 ? tokens.get(\"YY\") : tokens.get(\"YYYY\")\n    case \"month\":\n      if (n) return l === 1 ? tokens.get(\"M\") : tokens.get(\"MM\")\n      style = partStyle(locale, partName, partValue)\n      switch (style) {\n        case \"long\":\n          return tokens.get(\"MMMM\")\n        default:\n          return tokens.get(\"MMM\")\n      }\n    case \"day\":\n      return l === 1 ? tokens.get(\"D\") : tokens.get(\"DD\")\n    case \"weekday\":\n      style = partStyle(locale, partName, partValue)\n      switch (style) {\n        case \"narrow\":\n          return tokens.get(\"d\")\n        case \"short\":\n          return tokens.get(\"ddd\")\n        default:\n          return tokens.get(\"dddd\")\n      }\n    case \"hour\":\n      // Need to distinguish the locale’s default as 24 or 12 hour.\n      if (hour === 12) return l === 1 ? tokens.get(\"h\") : tokens.get(\"hh\")\n      return l === 1 ? tokens.get(\"H\") : tokens.get(\"HH\")\n    case \"minute\":\n      return l === 1 ? tokens.get(\"m\") : tokens.get(\"mm\")\n    case \"second\":\n      return l === 1 ? tokens.get(\"s\") : tokens.get(\"ss\")\n    case \"dayPeriod\":\n      return /^[A-Z]+$/u.test(partValue) ? tokens.get(\"A\") : tokens.get(\"a\")\n    case \"literal\":\n      return [partValue, { literal: partValue }, new RegExp(\"\")]\n    case \"timeZoneName\":\n      const offset = partValue.split(\"-\")\n      return offset.length === 2 && offset[1].length === 4\n        ? tokens.get(\"ZZ\")\n        : tokens.get(\"Z\")\n    default:\n      return undefined\n  }\n  /* eslint-enable @typescript-eslint/no-non-null-assertion */\n}\n\n/**\n * Determines what \"style\" a given part is in. For example, if you provide:\n * ```js\n * partStyle('en', 'month', 'Jan')\n * // returns \"short\".\n * ```\n * Part styles are always expected to be \"genitive\" — for use in \"dateStyle\".\n * @param locale - Locale string\n * @param part - The part to attempt a lookup on\n * @param value - The value of a given part.\n */\nfunction partStyle(\n  locale: string,\n  part: keyof NamedFormats,\n  value: string\n): NamedFormatOption | undefined {\n  if (!memoParts.has(locale)) {\n    const date = new Date(specDate)\n    const weekdays = [3, 8, 9, 7, 6, 4, 3]\n    const parts = [\"weekday\", \"month\", \"dayPeriod\"]\n    const partStyles: NamedFormatOption[] = [\"long\", \"short\", \"narrow\"]\n    const formats: Partial<NamedFormats> = {}\n    for (let i = 0; i < 12; i++) {\n      date.setMonth(0 + i)\n      if (i in weekdays) date.setDate(weekdays[i])\n      date.setUTCHours(8 + i)\n      for (const style of partStyles) {\n        const segments = new Intl.DateTimeFormat(\n          locale,\n          parts.reduce(\n            (options, part) => Object.assign(options, { [part]: style }),\n            { hour12: true, timeZone: \"UTC\" }\n          )\n        )\n          .formatToParts(date)\n          .map(normStr)\n        if (style === \"long\" || style === \"short\") {\n          const genitiveFormattedParts = new Intl.DateTimeFormat(locale, {\n            dateStyle: style === \"short\" ? \"medium\" : \"long\",\n            timeZone: \"UTC\",\n          })\n            .formatToParts(date)\n            .map(normStr)\n          const genitiveMonth = genitiveFormattedParts.find(\n            (part) => part.type === \"month\"\n          )\n          const index = segments.findIndex((part) => part.type === \"month\")\n          if (index > -1 && genitiveMonth) segments[index] = genitiveMonth\n        }\n        segments.forEach((part) => {\n          if (part.type === \"literal\") return\n          const type = part.type as keyof NamedFormats\n          formats[type] = Object.assign(formats[type] || {}, {\n            [part.value]: style,\n          })\n        })\n      }\n    }\n    memoParts.set(locale, formats as NamedFormats)\n  }\n  const formats = memoParts.get(locale)\n  return formats ? formats[part][value] : undefined\n}\n","import { applyOffset } from \"./applyOffset\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Inverts the offset and applies it to the given date, returning a new date.\n * @param dateInput - The date to remove the offset from.\n * @param offset - The offset to remove in the +-HHmm format.\n */\nexport function removeOffset(dateInput: DateInput, offset = \"+0000\"): Date {\n  const positive = offset.slice(0, 1) === \"+\"\n  return applyOffset(\n    dateInput,\n    offset.replace(positive ? \"+\" : \"-\", positive ? \"-\" : \"+\")\n  )\n}\n","/**\n * Returns the device's locale. This is a simple proxy of the\n * `Intl.DateTimeFormat().resolvedOptions().locale` call.\n */\nexport function deviceLocale() {\n  return Intl.DateTimeFormat().resolvedOptions().locale\n}\n","import { date } from \"./date\"\nimport { parts } from \"./parts\"\nimport { fill } from \"./common\"\nimport type { DateInput, Format, FormatOptions, Part } from \"./types\"\nimport { offset } from \"./offset\"\nimport { removeOffset } from \"./removeOffset\"\nimport { deviceLocale } from \"./deviceLocale\"\nimport { deviceTZ } from \"./deviceTZ\"\n\n/**\n * Produce a formatted string. Available strings:\n * token | description\n * ------|------------\n * YY | 2 digit year\n * YYYY | 4 digit year\n * M | The month 1-12\n * MM | The month 01-12\n * MMM | Short name Jan-Dec\n * MMMM | Full name January | December\n * D | The day of the month 1-31\n * DD | The day of the month 01-31\n * d | Single digit day \"T\"\n * ddd | Short day name Thu\n * dddd | Full day name Wednesday\n * H | Minimum hour digits, 24 hour, 0-23\n * HH | 2 hour digits, 24 hour, 00-23\n * h | Minimum hour digits, 12 hour clock, 1-12\n * hh | 2 hour digits, 12 hour clock, 01-12\n * m | The minute 0-59\n * mm | The minute 00-59\n * s | The second 0-59\n * ss | The second 00-59\n * a | am/pm\n * A | AM/PM\n * Z | +0800, +0530, -1345\n *\n * @param inputDate - A date object or ISO 8601 string\n * @param format - A format\n */\nexport function format(options: FormatOptions): string\nexport function format(\n  inputDate: DateInput,\n  format?: Format,\n  locale?: string,\n  genitive?: boolean,\n  partFilter?: (part: Part) => boolean\n): string\nexport function format(\n  inputDateOrOptions: DateInput | FormatOptions,\n  format: Format = \"long\",\n  locale: string | undefined = \"device\",\n  genitive: boolean | undefined = false,\n  partFilter?: (part: Part) => boolean\n): string {\n  let tz: string | undefined, forceOffset: string | undefined\n\n  if (\n    typeof inputDateOrOptions === \"object\" &&\n    !(inputDateOrOptions instanceof Date)\n  ) {\n    // Extract options from the object.\n    ;({\n      date: inputDateOrOptions,\n      format,\n      locale,\n      genitive,\n      partFilter,\n      tz,\n    } = inputDateOrOptions)\n  }\n  // ISO 8601 is a special case because it doesn't require a format.\n  if (format === \"ISO8601\") return date(inputDateOrOptions).toISOString()\n\n  if (tz) {\n    forceOffset = offset(inputDateOrOptions, \"utc\", tz)\n  }\n\n  // We need to apply an offset to the date so that it can be formatted as UTC.\n  tz ??= deviceTZ()\n  if (tz?.toLowerCase() !== \"utc\") {\n    inputDateOrOptions = removeOffset(\n      inputDateOrOptions,\n      offset(inputDateOrOptions, tz, \"utc\")\n    )\n  }\n\n  if (!locale || locale === \"device\") {\n    locale = deviceLocale()\n  }\n\n  return fill(\n    inputDateOrOptions,\n    parts(format, locale).filter(partFilter ?? (() => true)),\n    locale,\n    genitive,\n    forceOffset\n  )\n    .map((p) => p.value)\n    .join(\"\")\n}\n","import { parts } from \"./parts\"\nimport { escapeTokens } from \"./common\"\nimport type { Format, Part } from \"./types\"\n\n/**\n * Return the string format for a given format. For example:\n * ```js\n * formatStr({ date: 'long' }, 'en') // dddd, MMMM D, YYYY\n * ```\n * @param format - A format string or object.\n * @param locale - A locale or en by default.\n */\nexport function formatStr(\n  format: Format,\n  locale = \"en\",\n  escapeLiterals = false,\n  filterParts: (part: Part) => boolean = () => true\n): string {\n  return parts(format, locale)\n    .filter(filterParts)\n    .reduce(\n      (f, p) =>\n        (f +=\n          escapeLiterals && p.partName === \"literal\"\n            ? escapeTokens(p.token)\n            : p.token),\n      \"\"\n    )\n    .normalize(\"NFKC\")\n}\n","/**\n * Converts a 2 digit year into a 4 digit year. This function assumes years 20\n * years into the future belong to the current century, and the past 80 are in\n * the past.\n *\n * @param value - 2 digits in string format\n */\nexport function fourDigitYear(value: string): number {\n  const y = new Date().getFullYear()\n  const currentYear = y % 100\n  const century = Math.floor(y / 100)\n  const parsedYear = Number(value)\n  return (century + (parsedYear > currentYear + 20 ? -1 : 0)) * 100 + parsedYear\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given hour.\n * @param inputDate - A string or Date object\n */\nexport function hourEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setMinutes(59, 59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given hour.\n * @param inputDate - A string or Date object\n */\nexport function hourStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setMinutes(0, 0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for end of the given minute.\n * @param inputDate - A string or Date object\n */\nexport function minuteEnd(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setSeconds(59, 999)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given minute.\n * @param inputDate - A string or Date object\n */\nexport function minuteStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setSeconds(0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the first day of a month.\n * @param inputDate - A string or Date object\n */\nexport function monthStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n  d.setDate(1)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Get the number of days in the given date’s year.\n * @param inputDate - A string or Date object\n */\nexport function yearDays(inputDate: DateInput): number {\n  const d = date(inputDate)\n  return (\n    (new Date(d.getFullYear() + 1, 0, 0).getTime() -\n      new Date(d.getFullYear(), 0, 0).getTime()) /\n    86400000\n  )\n}\n","import { date } from \"./date\"\nimport { monthDays } from \"./monthDays\"\nimport { yearDays } from \"./yearDays\"\nimport { dayOfYear } from \"./dayOfYear\"\nimport { addDay } from \"./addDay\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Performs a bidirectional search for the nearest date that passes a function.\n * @param target - Performs a search for the nearest passing date.\n * @param search - The search function to use, given a date returns a boolean.\n * @param constraint - The number of iterations to perform before giving up, or logical constraint like \"month\", or \"week\".\n *\n */\nexport function nearestDay(\n  inputDate: DateInput,\n  search: (date: Date) => boolean,\n  constraint: number | \"month\" | \"week\" | \"year\" = 7\n): Date | null {\n  let increments: number\n  let decrements: number\n  const d = date(inputDate)\n  switch (constraint) {\n    case \"month\":\n      decrements = d.getDate()\n      increments = monthDays(d) - d.getDate()\n      break\n    case \"week\":\n      decrements = d.getDay() + 1\n      increments = 6 - d.getDay()\n      break\n    case \"year\":\n      const total = yearDays(d)\n      const day = dayOfYear(d)\n      decrements = day\n      increments = total - day\n      break\n    default:\n      increments = decrements = constraint\n  }\n\n  for (let i = 0; i <= increments || i < decrements; i++) {\n    if (i <= increments) {\n      const next = addDay(d, i)\n      if (search(next)) return next\n    }\n    if (i && i <= decrements) {\n      const prev = addDay(d, -i)\n      if (search(prev)) return prev\n    }\n  }\n  return null\n}\n","import { format } from \"./format\"\nimport { ap } from \"./ap\"\nimport type { FormatToken } from \"./types\"\n/**\n * Returns an array of options for a given token in a given locale.\n * @param token - Get the full range of options for a given token\n * @param locale - The locale to fetch the options for.\n */\nexport function range(\n  token: FormatToken,\n  locale = \"en\",\n  genitive = false\n): string[] {\n  const r: (n: number, c: (index: number) => string | number) => string[] = (\n    n,\n    c\n  ) =>\n    Array(n)\n      .fill(\"\")\n      .map((_, i) => `${c(i)}`)\n\n  if (token === \"M\") return r(12, (i) => i + 1)\n  if (token === \"MM\")\n    return r(12, (i) => {\n      const m = i + 1\n      return m < 10 ? `0${m}` : m\n    })\n  // MMM and MMMM\n  if (token.startsWith(\"M\"))\n    return range(\"MM\").map((m) =>\n      format(`2000-${m}-05`, token, locale, genitive)\n    )\n  if (token.startsWith(\"d\"))\n    return r(7, (i) => `0${i + 2}`).map((d) =>\n      format(`2022-10-${d}`, token, locale)\n    )\n  if (token === \"a\")\n    return [ap(\"am\", locale).toLowerCase(), ap(\"pm\", locale).toLowerCase()]\n  if (token === \"A\")\n    return [ap(\"am\", locale).toUpperCase(), ap(\"pm\", locale).toUpperCase()]\n  if (token.startsWith(\"Y\")) {\n    const year = new Date().getFullYear()\n    return r(120, (i) => i + 1).reduce(\n      (ranges, i) => {\n        if (i !== \"120\")\n          ranges.push(format(`${year + Number(i)}-06-06`, token, locale))\n        ranges.unshift(format(`${year - Number(i)}-06-06`, token, locale))\n        return ranges\n      },\n      [format(`${year}-06-06`, token, locale)]\n    )\n  }\n  if (token.startsWith(\"D\"))\n    return r(31, (i) => `${token === \"DD\" && i < 9 ? \"0\" : \"\"}${i + 1}`)\n  if (token.startsWith(\"H\"))\n    return r(24, (i) => `${token === \"HH\" && i < 10 ? \"0\" : \"\"}${i}`)\n  if (token.startsWith(\"h\"))\n    return r(12, (i) => `${token === \"hh\" && i < 9 ? \"0\" : \"\"}${i + 1}`)\n  if (token.startsWith(\"m\") || token.startsWith(\"s\"))\n    return r(60, (i) => `${token.length > 1 && i < 10 ? \"0\" : \"\"}${i}`)\n  return []\n}\n","import { date } from \"./date\"\nimport { validate, styles, fixedLength, four, two, validOffset, fixedLengthByOffset } from \"./common\"\nimport { formatStr } from \"./formatStr\"\nimport { fourDigitYear } from \"./fourDigitYear\"\nimport { ap } from \"./ap\"\nimport { range } from \"./range\"\nimport { monthDays } from \"./monthDays\"\nimport { parts } from \"./parts\"\nimport type {\n  ParseOptions,\n  Format,\n  Part,\n  FormatStyle,\n  FilledPart,\n  FormatToken,\n} from \"./types\"\n\nexport function parse(options: ParseOptions): Date | never\nexport function parse(\n  dateStr: string,\n  format?: Format,\n  locale?: string\n): Date | never\n/**\n * Parses a date string into a Date object using the given format.\n * @param dateStr - A string representing a date.\n * @param format - The format the given string is in.\n * @param locale - The locale to parse the string from.\n */\nexport function parse(\n  dateStrOrOptions: string | ParseOptions,\n  format: Format = \"ISO8601\",\n  locale = \"device\"\n): Date | never {\n  let partFilter: (part: Part) => boolean = () => true\n  let dateStr: string\n  let dateOverflow = \"backward\"\n  if (typeof dateStrOrOptions === \"object\") {\n    ;({\n      date: dateStr,\n      format = \"ISO8601\",\n      locale = \"device\",\n      dateOverflow = \"backward\",\n      partFilter = () => true,\n    } = dateStrOrOptions)\n  } else {\n    dateStr = dateStrOrOptions\n  }\n  if (!dateStr) throw new Error(\"parse() requires a date string.\")\n  const invalid = (): never => {\n    throw new Error(\n      `Date (${dateStr}) does not match format (${formatStr(format, locale)})`\n    )\n  }\n  if (format === \"ISO8601\") return date(dateStr)\n  const genitive =\n    styles.includes(format as FormatStyle) || typeof format === \"object\"\n  const formatParts = validate(parts(format, locale).filter(partFilter))\n  if (!formatParts.length) throw new Error(\"parse() requires a pattern.\")\n  let parsedParts\n  try {\n    parsedParts = parseParts(dateStr, formatParts)\n  } catch {\n    return invalid()\n  }\n  const now = new Date()\n  const parsed = new Map([\n    [\"YYYY\", now.getFullYear()],\n    [\"MM\", now.getMonth() + 1],\n    [\"DD\", now.getDate()],\n    [\"HH\", 0],\n    [\"mm\", 0],\n    [\"ss\", 0],\n  ])\n  let a: null | boolean = null\n  let offset = \"\"\n  parsedParts.forEach((part): void | never => {\n    if (part.partName === \"literal\") return\n    if (part.token === part.value) return invalid()\n    const v = Number(part.value)\n    if (parsed.has(part.token)) {\n      // Parse for YYYY, MM, DD, HH, hh, mm, ss, Z\n      parsed.set(part.token, v)\n    } else if (part.token === \"YY\") {\n      // Parse for YY\n      parsed.set(\"YYYY\", fourDigitYear(part.value))\n    } else {\n      /* MMM - Short name Jan-Dec\n       * MMMM - Full name January - December\n       * h - Minimum hour digits, 12 hour clock, 1-12\n       * hh - 2 hour digits, 12 hour clock, 01-12\n       * m - The minute 0-59\n       * mm - The minute 00-12\n       * s - The second 0-59\n       * a - am/pm\n       * A - AM/PM\n       */\n      const t = part.token\n      if (t.startsWith(\"d\")) {\n        // d, ddd, dddd — we just ignore these because they are non specific\n        return\n      } else if (t === \"D\") {\n        parsed.set(\"DD\", v)\n      } else if (t === \"H\" || t.startsWith(\"h\")) {\n        parsed.set(\"HH\", v)\n      } else if (t === \"M\") {\n        parsed.set(\"MM\", v)\n      } else if (t === \"a\" || t === \"A\") {\n        a = part.value.toLowerCase() === ap(\"am\", locale).toLowerCase()\n      } else if (t === \"Z\") {\n        offset = validOffset(part.value)\n      } else {\n        const values = range(t as FormatToken, locale, genitive)\n        const index = values.indexOf(part.value)\n        if (index !== -1) {\n          switch (t) {\n            case \"MMM\":\n            case \"MMMM\":\n              parsed.set(\"MM\", index + 1)\n              break\n          }\n        }\n      }\n    }\n  })\n  let hours = parsed.get(\"HH\") || 0\n  if (a === false) {\n    hours += hours === 12 ? 0 : 12\n    parsed.set(\"HH\", hours === 24 ? 0 : hours)\n  } else if (a === true && hours === 12) {\n    // 12am === 00 in 24 hour clock.\n    parsed.set(\"HH\", 0)\n  }\n  parsed.set(\"MM\", (parsed.get(\"MM\") || 1) - 1)\n  // eslint-disable-next-line prefer-const\n  let [Y, M, D, h, m, s] = Array.from(parsed.values())\n\n  // Determine if the date is valid for the month.\n  const maxDaysInMonth = monthDays(new Date(`${four(Y)}-${two(M + 1)}-10`))\n  if (maxDaysInMonth < D && dateOverflow === \"throw\")\n    throw new Error(`Invalid date ${four(Y)}-${two(M + 1)}-${two(D)}`)\n  D = dateOverflow === \"backward\" ? Math.min(D, maxDaysInMonth) : D\n\n  // Create the date.\n  const isoString = `${four(Y)}-${two(M + 1)}-${two(D)}T${two(h)}:${two(\n    m\n  )}:${two(s)}${offset}`\n  const d = new Date(isoString)\n  if (isFinite(+d)) return d\n  return invalid()\n}\n\n/**\n * Given a string date and corresponding format parts, fill the parts with the\n * data from the string.\n * @param dateStr - A string to parse.\n * @param formatParts - The expected parts of the given string.\n */\nexport function parseParts(dateStr: string, formatParts: Part[]): FilledPart[] {\n  let i = 0\n  const advance = (parts: Part[]): [Part, Part | undefined] => [\n    parts[i++],\n    parts[i],\n  ]\n  let pos = 0\n  const parsed: FilledPart[] = []\n  let n: undefined | Part = undefined\n  do {\n    const [current, next] = advance(formatParts)\n    n = next\n    let len = 1\n    if (current.partName === \"literal\") {\n      // Literals can be discarded\n      len = current.partValue.length\n    } else if (current.partName === \"timeZoneName\") {\n      len = fixedLengthByOffset(dateStr.substring(pos))\n    } else if (current.token in fixedLength) {\n      // Fixed length parse\n      len = fixedLength[current.token as keyof typeof fixedLength]\n    } else if (next) {\n      // Variable length parse.\n      if (next.partName === \"literal\") {\n        len = dateStr.indexOf(next.partValue, pos) - pos\n        if (len < 0) throw new Error()\n      } else if (next.partName === \"dayPeriod\") {\n        // Our validator is ensuring that the current item must be a variable\n        // length number. We need to extract it.\n        for (let i = 1; i <= 4; i++) {\n          if (isNaN(Number(dateStr.charAt(pos + i)))) {\n            len = i\n            break\n          }\n        }\n      } else {\n        // Our validator guarantees the next is either not a number or it\n        // will be the end of the string\n        const nextChar = dateStr.substring(pos).search(/\\d/)\n        if (nextChar !== -1) len = pos + nextChar\n      }\n    } else {\n      len = dateStr.length\n    }\n\n    parsed.push({ ...current, value: dateStr.substring(pos, pos + len) })\n    pos += len\n  } while (n)\n  return parsed\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same date. Ignores time.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameDay(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return (\n    a.getDate() === b.getDate() &&\n    a.getMonth() === b.getMonth() &&\n    a.getFullYear() === b.getFullYear()\n  )\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time seconds. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameSecond(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getSeconds() === b.getSeconds()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time minutes. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameMinute(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getMinutes() === b.getMinutes()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same time hour. Ignores date.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameHour(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getHours() === b.getHours()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Checks if two date objects refer to the same year.\n * @param inputDateA - First date to compare\n * @param inputDateB - Second date to compare\n */\nexport function sameYear(inputDateA: DateInput, inputDateB: DateInput) {\n  const a = date(inputDateA)\n  const b = date(inputDateB)\n  return a.getFullYear() === b.getFullYear()\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for start of the given week. Defaults to Sunday as the\n * first day of the week:\n * 0 = Sunday ... 6 = Saturday\n * @param inputDate - A string or Date object\n * @param startOfWeekDay - Determines which day of the week is the first\n */\nexport function weekStart(inputDate: DateInput, startOfWeekDay = 0): Date {\n  const d = date(inputDate)\n  let diff = startOfWeekDay - d.getDay()\n  if (diff > 0) diff = diff - 7\n  d.setDate(d.getDate() + diff)\n  d.setHours(0, 0, 0)\n  return d\n}\n","import { weekStart } from \"./weekStart\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the last day at the last second of the given week.\n * Defaults to Sunday as the first day of the week:\n * 0 = Sunday ... 6 = Saturday\n * @param inputDate - Gets the last day of the week\n * @param startOfWeekDay - The first day of the week\n */\nexport function weekEnd(inputDate: DateInput, startOfWeekDay = 0): Date {\n  const d = weekStart(inputDate, startOfWeekDay)\n  d.setDate(d.getDate() + 6)\n  d.setHours(23, 59, 59)\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the start of the current year.\n * @param inputDate - A string or Date object\n */\nexport function yearStart(inputDate: DateInput): Date {\n  const d = date(inputDate)\n\n  d.setMonth(0)\n  d.setDate(1)\n  d.setHours(0, 0, 0)\n\n  return d\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Returns a Date object for the with the input date set to the end of the current year.\n * @param inputDate - A string or Date object\n */\nexport function yearEnd(inputDate: DateInput): Date {\n  const d = date(inputDate);\n\n  d.setMonth(11);\n  d.setDate(31);\n  d.setHours(23, 59, 59, 999);\n\n  return d;\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Is the first date before the second one?\n *\n * @param inputDate - The date that should be before the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is before the second date.\n */\nexport function isBefore(inputDate: DateInput, dateToCompare: DateInput) {\n  const _date = date(inputDate)\n  const _dateToCompare = date(dateToCompare)\n\n  return +_date < +_dateToCompare\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * @name isAfter\n * @category Common Helpers\n * @summary Is the first date after the second one?\n *\n * @description\n * Is the first date after the second one?\n *\n * @param inputDate - The date that should be after the other one to return true\n * @param dateToCompare - The date to compare with\n *\n * @returns The first date is after the second date.\n */\nexport function isAfter(inputDate: DateInput, dateToCompare: DateInput) {\n  const _date = date(inputDate)\n  const _dateToCompare = date(dateToCompare)\n\n  return +_date > +_dateToCompare\n}\n","import { date } from \"./date\"\nimport type { DateInput } from \"./types\"\n\n/**\n * Are the given dates equal?\n *\n * @param dateLeft - The first date to compare\n * @param dateRight - The second date to compare\n *\n * @returns The dates are equal.\n */\nexport function isEqual(dateLeft: DateInput, dateRight: DateInput) {\n  const _dateLeft = date(dateLeft)\n  const _dateRight = date(dateRight)\n\n  return +_dateLeft === +_dateRight\n}\n"],"mappings":"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","names":["date","date","format","parts","offset","value","hour12","offset","parts","format","validate","parts","match","offset","date","formats","part","offset","format","format","format","offset","parts","i"]}