{"version":3,"sources":["../src/format.ts"],"sourcesContent":["import { date } from \"./date\"\nimport { parts } from \"./parts\"\nimport { fill } from \"./common\"\nimport type { DateInput, Format, FormatOptions, Part } from \"./types\"\nimport { offset } from \"./offset\"\nimport { removeOffset } from \"./removeOffset\"\nimport { deviceLocale } from \"./deviceLocale\"\nimport { deviceTZ } from \"./deviceTZ\"\n\n/**\n * Produce a formatted string. Available strings:\n * token | description\n * ------|------------\n * YY | 2 digit year\n * YYYY | 4 digit year\n * M | The month 1-12\n * MM | The month 01-12\n * MMM | Short name Jan-Dec\n * MMMM | Full name January | December\n * D | The day of the month 1-31\n * DD | The day of the month 01-31\n * d | Single digit day \"T\"\n * ddd | Short day name Thu\n * dddd | Full day name Wednesday\n * H | Minimum hour digits, 24 hour, 0-23\n * HH | 2 hour digits, 24 hour, 00-23\n * h | Minimum hour digits, 12 hour clock, 1-12\n * hh | 2 hour digits, 12 hour clock, 01-12\n * m | The minute 0-59\n * mm | The minute 00-59\n * s | The second 0-59\n * ss | The second 00-59\n * a | am/pm\n * A | AM/PM\n * Z | +0800, +0530, -1345\n *\n * @param inputDate - A date object or ISO 8601 string\n * @param format - A format\n */\nexport function format(options: FormatOptions): string\nexport function format(\n  inputDate: DateInput,\n  format?: Format,\n  locale?: string,\n  genitive?: boolean,\n  partFilter?: (part: Part) => boolean\n): string\nexport function format(\n  inputDateOrOptions: DateInput | FormatOptions,\n  format: Format = \"long\",\n  locale: string | undefined = \"device\",\n  genitive: boolean | undefined = false,\n  partFilter?: (part: Part) => boolean\n): string {\n  let tz: string | undefined, forceOffset: string | undefined\n\n  if (\n    typeof inputDateOrOptions === \"object\" &&\n    !(inputDateOrOptions instanceof Date)\n  ) {\n    // Extract options from the object.\n    ;({\n      date: inputDateOrOptions,\n      format,\n      locale,\n      genitive,\n      partFilter,\n      tz,\n    } = inputDateOrOptions)\n  }\n  // ISO 8601 is a special case because it doesn't require a format.\n  if (format === \"ISO8601\") return date(inputDateOrOptions).toISOString()\n\n  if (tz) {\n    forceOffset = offset(inputDateOrOptions, \"utc\", tz)\n  }\n\n  // We need to apply an offset to the date so that it can be formatted as UTC.\n  tz ??= deviceTZ()\n  if (tz?.toLowerCase() !== \"utc\") {\n    inputDateOrOptions = removeOffset(\n      inputDateOrOptions,\n      offset(inputDateOrOptions, tz, \"utc\")\n    )\n  }\n\n  if (!locale || locale === \"device\") {\n    locale = deviceLocale()\n  }\n\n  return fill(\n    inputDateOrOptions,\n    parts(format, locale).filter(partFilter ?? (() => true)),\n    locale,\n    genitive,\n    forceOffset\n  )\n    .map((p) => p.value)\n    .join(\"\")\n}\n"],"mappings":";AAAA,SAAS,YAAY;AACrB,SAAS,aAAa;AACtB,SAAS,YAAY;AAErB,SAAS,cAAc;AACvB,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,SAAS,gBAAgB;AAwClB,SAAS,OACd,oBACAA,UAAiB,QACjB,SAA6B,UAC7B,WAAgC,OAChC,YACQ;AACR,MAAI,IAAwB;AAE5B,MACE,OAAO,uBAAuB,YAC9B,EAAE,8BAA8B,OAChC;AAEA;AAAC,KAAC;AAAA,MACA,MAAM;AAAA,MACN,QAAAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI;AAAA,EACN;AAEA,MAAIA,YAAW;AAAW,WAAO,KAAK,kBAAkB,EAAE,YAAY;AAEtE,MAAI,IAAI;AACN,kBAAc,OAAO,oBAAoB,OAAO,EAAE;AAAA,EACpD;AAGA,yBAAO,SAAS;AAChB,OAAI,yBAAI,mBAAkB,OAAO;AAC/B,yBAAqB;AAAA,MACnB;AAAA,MACA,OAAO,oBAAoB,IAAI,KAAK;AAAA,IACtC;AAAA,EACF;AAEA,MAAI,CAAC,UAAU,WAAW,UAAU;AAClC,aAAS,aAAa;AAAA,EACxB;AAEA,SAAO;AAAA,IACL;AAAA,IACA,MAAMA,SAAQ,MAAM,EAAE,OAAO,kCAAe,MAAM,IAAK;AAAA,IACvD;AAAA,IACA;AAAA,IACA;AAAA,EACF,EACG,IAAI,CAAC,MAAM,EAAE,KAAK,EAClB,KAAK,EAAE;AACZ;","names":["format"]}