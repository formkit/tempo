{"version":3,"sources":["../src/types.ts"],"sourcesContent":["/**\n * The date format used as an input value. Either a date or an ISO8601 string.\n */\nexport type DateInput = Date | string\n\n/**\n * Format parts with text names use these descriptors:\n */\nexport type NamedFormatOption = \"long\" | \"short\" | \"narrow\"\n\n/**\n * A registry of named format parts. Each type of part has every option.\n */\nexport interface NamedFormats {\n  weekday: Record<string, NamedFormatOption>\n  month: Record<string, NamedFormatOption>\n  dayPeriod: Record<string, NamedFormatOption>\n}\n\n/**\n * Internal format for \"pieces\" of a date form. Each part represents a single\n * logical grouping, like \"month\", or \"seconds\".\n */\nexport interface Part {\n  /**\n   * An object of partName to partValue For example:\n   * ```js\n   * { hour: '2-digit' }\n   * ```\n   */\n  option: FormatPattern[1]\n  /**\n   * The name of the part, these must be valid parts of a date format as\n   * specified in Intl.DateTimeFormatPartTypes. Valid values are:\n   * day, dayPeriod, era, hour, literal, minute, month, second, timeZoneName,\n   * weekday, year\n   */\n  partName: Intl.DateTimeFormatPartTypes\n  /**\n   * The value of a given part. For example \"2-digit\", or \"narrow\".\n   */\n  partValue: string\n  /**\n   * The string token that represents the regex. For example \"YYYY\".\n   */\n  token: string\n  /**\n   * A regular expression if the above token.\n   */\n  pattern: RegExp\n  /**\n   * Does this part require a the hour12 clock.\n   */\n  hour12: boolean\n}\n\n/**\n * A date part with an actual value applied.\n */\nexport type FilledPart = Part & { value: string }\n\n/**\n * A tuple describing a given formatting token.\n */\nexport type FormatPattern = [\n  pattern: FormatToken | string,\n  option: Partial<Record<Intl.DateTimeFormatPartTypes, string>>,\n  exp?: RegExp\n]\n\n/**\n * Possible options for a format style.\n */\nexport type FormatStyle = \"full\" | \"long\" | \"medium\" | \"short\"\n\n/**\n * Possible objects for the dateStyle and timeStyle.\n */\nexport type FormatStyleObj =\n  | { date: FormatStyle; time: FormatStyle }\n  | { date: FormatStyle }\n  | { time: FormatStyle }\n\nexport type Format = FormatStyle | FormatStyleObj | string\n\n/**\n * A union of all available formatting tokens.\n */\nexport type FormatToken =\n  | \"YYYY\"\n  | \"YY\"\n  | \"MMMM\"\n  | \"MMM\"\n  | \"MM\"\n  | \"M\"\n  | \"DD\"\n  | \"D\"\n  | \"dddd\"\n  | \"ddd\"\n  | \"d\"\n  | \"mm\"\n  | \"m\"\n  | \"ss\"\n  | \"s\"\n  | \"HH\"\n  | \"H\"\n  | \"hh\"\n  | \"h\"\n  | \"a\"\n  | \"A\"\n  | \"ZZ\"\n  | \"Z\"\n\nexport interface ParseOptions {\n  /**\n   * A string representing a date.\n   */\n  date: string\n  /**\n   * The format that should be used to parse the date. This is a string composed\n   * of tokens.\n   */\n  format: Format\n  /**\n   * The locale used to parse the date.\n   */\n  locale: string\n  /**\n   * A function that can be used to filter out parts of the format. This is\n   * useful when using the native Intl formats like\n   * `{ date: 'full', time: 'full' }` and not wanting to keep all the parts of\n   * the given format.\n   */\n  partFilter?: (part: Part) => boolean\n  /**\n   * The behavior to use when a date overflows a given month. For example, if\n   * the date to parse is February 29, 2023 — there is no 29th day of February.\n   * In this case overflow \"forward\" would result in March 1, 2023, \"backward\"\n   * would result in February 28, 2023, and \"throw\" would throw an error.\n   */\n  dateOverflow?: \"forward\" | \"backward\" | \"throw\"\n}\n\nexport interface FormatOptions {\n  /**\n   * A date object or ISO 8601 string.\n   */\n  date: DateInput\n  /**\n   * A format string or object.\n   */\n  format: Format\n  /**\n   * A locale or en by default.\n   */\n  locale?: string\n  /**\n   * Whether or not to escape literals.\n   */\n  genitive?: boolean\n  /**\n   * A function to filter parts.\n   */\n  tz?: string\n  /**\n   * A function to filter parts.\n   */\n  partFilter?: (part: Part) => boolean\n}\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}