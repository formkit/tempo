{"version":3,"sources":["../src/common.ts"],"names":["value","hour12"],"mappings":";AAAA,SAAS,YAAY;AACrB,SAAS,UAAU;AAaZ,IAAM,WAAW;AAKjB,IAAM,YAAuC,oBAAI,IAAI;AAKrD,IAAM,gBAAiC;AAAA,EAC5C,CAAC,QAAQ,EAAE,MAAM,UAAU,CAAC;AAAA,EAC5B,CAAC,MAAM,EAAE,MAAM,UAAU,CAAC;AAAA,EAC1B,CAAC,QAAQ,EAAE,OAAO,OAAO,CAAC;AAAA,EAC1B,CAAC,OAAO,EAAE,OAAO,QAAQ,CAAC;AAAA,EAC1B,CAAC,MAAM,EAAE,OAAO,UAAU,CAAC;AAAA,EAC3B,CAAC,KAAK,EAAE,OAAO,UAAU,CAAC;AAAA,EAC1B,CAAC,MAAM,EAAE,KAAK,UAAU,CAAC;AAAA,EACzB,CAAC,KAAK,EAAE,KAAK,UAAU,CAAC;AAAA,EACxB,CAAC,QAAQ,EAAE,SAAS,OAAO,CAAC;AAAA,EAC5B,CAAC,OAAO,EAAE,SAAS,QAAQ,CAAC;AAAA,EAC5B,CAAC,KAAK,EAAE,SAAS,SAAS,CAAC;AAAA,EAC3B,CAAC,MAAM,EAAE,QAAQ,UAAU,CAAC;AAAA,EAC5B,CAAC,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,EAC3B,CAAC,MAAM,EAAE,QAAQ,UAAU,CAAC;AAAA,EAC5B,CAAC,KAAK,EAAE,QAAQ,UAAU,CAAC;AAAA,EAC3B,CAAC,KAAK,EAAE,cAAc,QAAQ,CAAC;AACjC;AAKO,IAAM,UAA2B;AAAA,EACtC,CAAC,MAAM,EAAE,MAAM,UAAU,CAAC;AAAA,EAC1B,CAAC,KAAK,EAAE,MAAM,UAAU,CAAC;AAC3B;AAKO,IAAM,UAA2B;AAAA,EACtC,CAAC,MAAM,EAAE,MAAM,UAAU,CAAC;AAAA,EAC1B,CAAC,KAAK,EAAE,MAAM,UAAU,CAAC;AAAA,EACzB,CAAC,KAAK,EAAE,WAAW,SAAS,CAAC;AAAA,EAC7B,CAAC,KAAK,EAAE,WAAW,SAAS,CAAC;AAC/B;AAKO,IAAM,cAAc;AAAA,EACzB,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AACN;AAKO,SAAS,oBAAoB,cAA8B;AAEhE,MAAI,mBAAmB,KAAK,YAAY,GAAG;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,aAAa,KAAK,YAAY,GAAG;AACnC,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,MAAM,uBAAuB;AACzC;AASO,IAAM,iBAAiB,CAAC,QAAQ,OAAO,QAAQ,KAAK;AAKpD,IAAM,SAAyB,oBAAI;AAAA,EACxB,iBAAC,GAAG,eAAe,GAAG,SAAS,GAAG,OAAO,EAAE,IAAI,CAAC,WAAW;AACzE,WAAO,CAAC,OAAO,CAAC,GAAG,MAAM;AAAA,EAC3B,CAAC;AACH;AAKO,IAAM,eAA0D,oBAAI,IAAI;AAKxE,IAAM,SAAqC;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAMO,IAAM,MAAM,CAAC,MAAc,OAAO,CAAC,EAAE,SAAS,GAAG,GAAG;AAKpD,IAAM,OAAO,CAAC,MAAc,OAAO,CAAC,EAAE,SAAS,GAAG,GAAG;AAMrD,SAAS,QACd,MACyB;AACzB,MAAI,KAAK,SAAS,WAAW;AAC3B,SAAK,QAAQ,KAAK,MAAM,UAAU,MAAM;AAAA,EAC1C;AACA,SAAO;AACT;AAUO,SAAS,KACd,WACA,OACA,QACA,WAAW,OACX,SAAwB,MACV;AACd,QAAM,UAAU,cAAc,WAAW,OAAO,QAAQ,QAAQ;AAChE,QAAM,IAAI,KAAK,SAAS;AAQxB,WAAS,MAAM,EAAE,UAAU,WAAW,MAAM,GAAS;AACnD,QAAI,aAAa;AAAW,aAAO;AACnC,UAAMA,SAAQ,QAAQ,QAAQ;AAC9B,QAAI,aAAa,UAAU,UAAU,KAAK;AACxC,aAAOA,OAAM,QAAQ,MAAM,EAAE,KAAK;AAAA,IACpC;AACA,QAAI,CAAC,MAAM,MAAM,IAAI,EAAE,SAAS,KAAK,KAAKA,OAAM,WAAW,GAAG;AAG5D,aAAO,IAAIA,MAAK;AAAA,IAClB;AACA,QAAI,aAAa,aAAa;AAC5B,YAAM,IAAI,GAAG,EAAE,YAAY,IAAI,KAAK,OAAO,MAAM,MAAM;AACvD,aAAO,UAAU,MAAM,EAAE,YAAY,IAAI,EAAE,YAAY;AAAA,IACzD;AACA,QAAI,aAAa,gBAAgB;AAC/B,aAAO,0BAAU,aAAa,KAAK,EAAE,kBAAkB,CAAC;AAAA,IAC1D;AACA,WAAOA;AAAA,EACT;AAEA,SAAO,MAAM,IAAI,CAAC,SAAqB;AACrC,WAAO;AAAA,MACL,GAAG;AAAA,MACH,OAAO,MAAM,IAAI;AAAA,IACnB;AAAA,EACF,CAAC;AACH;AASA,SAAS,cACP,WACA,OACA,QACA,WAAW,OACiD;AAC5D,QAAM,IAAI,KAAK,SAAS;AACxB,QAAM,SAAS,MAAM,OAAO,CAAC,SAAS,KAAK,MAAM;AACjD,QAAM,SAAS,MAAM,OAAO,CAAC,SAAS,CAAC,KAAK,MAAM;AAClD,QAAM,aAAwC,CAAC;AAC/C,QAAM,gBAAwB,CAAC;AAE/B,WAAS,UAAU,gBAAwBC,UAAS,OAAO;AACzD,UAAM,gBAAgB,GAAG,MAAM,SAASA,UAAS,QAAQ,KAAK;AAC9D,eAAW;AAAA,MACT,GAAG,IAAI,KAAK;AAAA,QACV;AAAA,QACA,eAAe;AAAA,UACb,CAAC,SAAS,SAAS;AACjB,gBAAI,KAAK,aAAa;AAAW,qBAAO;AAExC,gBAAI,YAAY,eAAe,SAAS,KAAK,KAAK,GAAG;AACnD,4BAAc,KAAK,IAAI;AAAA,YACzB;AACA,mBAAO,OAAO,OAAO,SAAS,KAAK,MAAM;AAAA,UAC3C;AAAA,UACA,EAAE,UAAU,MAAM;AAAA,QACpB;AAAA,MACF,EACG,cAAc,CAAC,EACf,IAAI,OAAO;AAAA,IAChB;AACA,QAAI,YAAY,cAAc,QAAQ;AACpC,iBAAW,QAAQ,eAAe;AAChC,YAAI,iBAA4C,CAAC;AACjD,gBAAQ,KAAK,OAAO;AAAA,UAClB,KAAK;AACH,6BAAiB,IAAI,KAAK,eAAe,eAAe;AAAA,cACtD,WAAW;AAAA,cACX,UAAU;AAAA,YACZ,CAAC,EACE,cAAc,CAAC,EACf,IAAI,OAAO;AACd;AAAA,UACF,KAAK;AACH,6BAAiB,IAAI,KAAK,eAAe,eAAe;AAAA,cACtD,WAAW;AAAA,cACX,UAAU;AAAA,YACZ,CAAC,EACE,cAAc,CAAC,EACf,IAAI,OAAO;AACd;AAAA,QACJ;AACA,cAAM,wBAAwB,eAAe;AAAA,UAC3C,CAAC,MAAM,EAAE,SAAS,KAAK;AAAA,QACzB;AACA,cAAM,QAAQ,WAAW,UAAU,CAAC,MAAM,EAAE,SAAS,KAAK,QAAQ;AAClE,YAAI,yBAAyB,QAAQ,IAAI;AACvC,qBAAW,KAAK,IAAI;AAAA,QACtB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,OAAO;AAAQ,cAAU,QAAQ,IAAI;AACzC,MAAI,OAAO;AAAQ,cAAU,MAAM;AAEnC,SAAO,WAAW,OAAO,CAAC,KAAK,SAAS;AACtC,QAAI,KAAK,IAAI,IAAI,KAAK;AACtB,WAAO;AAAA,EACT,GAAG,CAAC,CAA+D;AACrE;AAOO,SAAS,aAAa,gBAAgC;AAC3D,QAAM,QAAQ,OAAO,KAAK,MAAM,KAAK,IAAI,iBAAiB,EAAE,CAAC,CAAC,EAAE;AAAA,IAC9D;AAAA,IACA;AAAA,EACF;AACA,QAAM,OAAO,OAAO,KAAK,IAAI,iBAAiB,EAAE,CAAC,EAAE,SAAS,GAAG,GAAG;AAClE,QAAM,OAAO,iBAAiB,IAAI,MAAM;AACxC,SAAO,GAAG,IAAI,GAAG,KAAK,GAAG,IAAI;AAC/B;AAMO,SAAS,aAAa,QAAwB;AACnD,cAAY,MAAM;AAClB,QAAM,CAAC,GAAG,MAAM,OAAO,IAAI,IAAI,OAAO,MAAM,gCAAgC;AAC5E,QAAM,eAAe,OAAO,KAAK,IAAI,KAAK,OAAO,IAAI;AACrD,SAAO,SAAS,MAAM,eAAe,CAAC;AACxC;AAOO,SAAS,YAAY,QAAgB;AAC1C,QAAM,QAAQ,iCAAiC,KAAK,MAAM;AAC1D,MAAI,CAAC;AAAO,UAAM,IAAI,MAAM,mBAAmB,MAAM,EAAE;AACvD,SAAO;AACT;AAOO,SAAS,aAAa,KAAqB;AAChD,SAAO,cACJ,OAAO,OAAO,EACd,OAAO,OAAO,EACd,KAAK,CAAC,GAAG,MAAO,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE,SAAS,IAAI,EAAG,EACnD,OAAO,CAAC,QAAQ,SAAS;AACxB,WAAO,OAAO,QAAQ,KAAK,CAAC,GAAG,KAAK,KAAK,CAAC,CAAC,EAAE;AAAA,EAC/C,GAAG,GAAG;AACV;AAMO,SAAS,UAAU,MAAY;AACpC,SAAO,CAAC,WAAW,SAAS,EAAE,SAAS,KAAK,SAAS;AACvD;AAMO,SAAS,SAAS,OAA+B;AACtD,MAAI,WAA6B;AACjC,aAAW,QAAQ,OAAO;AACxB,QAAI,KAAK,aAAa,aAAa,CAAC,MAAM,WAAW,KAAK,SAAS,CAAC,GAAG;AACrE,YAAM,IAAI,MAAM,sBAAsB,KAAK,SAAS,IAAI;AAAA,IAC1D;AACA,QACE,YACA,SAAS,aAAa,aACtB,KAAK,aAAa,WAClB;AACA,UACE,EAAE,SAAS,SAAS,gBACpB,EAAE,KAAK,SAAS,gBAChB,EAAE,UAAU,QAAQ,KAAK,KAAK,MAAM,YAAY,MAAM,MACtD;AACA,cAAM,IAAI;AAAA,UACR,4BAA4B,SAAS,KAAK,KAAK,KAAK,KAAK;AAAA,QAC3D;AAAA,MACF;AAAA,IACF;AACA,eAAW;AAAA,EACb;AACA,SAAO;AACT","sourcesContent":["import { date } from \"./date\"\nimport { ap } from \"./ap\"\nimport type {\n  DateInput,\n  NamedFormats,\n  FormatPattern,\n  FormatStyle,\n  Part,\n  FilledPart,\n} from \"./types\"\n\n/**\n * A date to use for determining various spec details.\n */\nexport const specDate = \"1999-03-04T02:05:01.000Z\"\n\n/**\n * A cache of Intl tokens and their respective formats.\n */\nexport const memoParts: Map<string, NamedFormats> = new Map()\n\n/**\n * Clock agnostic time format patterns.\n */\nexport const clockAgnostic: FormatPattern[] = [\n  [\"YYYY\", { year: \"numeric\" }],\n  [\"YY\", { year: \"2-digit\" }],\n  [\"MMMM\", { month: \"long\" }],\n  [\"MMM\", { month: \"short\" }],\n  [\"MM\", { month: \"2-digit\" }],\n  [\"M\", { month: \"numeric\" }],\n  [\"DD\", { day: \"2-digit\" }],\n  [\"D\", { day: \"numeric\" }],\n  [\"dddd\", { weekday: \"long\" }],\n  [\"ddd\", { weekday: \"short\" }],\n  [\"d\", { weekday: \"narrow\" }],\n  [\"mm\", { minute: \"2-digit\" }],\n  [\"m\", { minute: \"numeric\" }],\n  [\"ss\", { second: \"2-digit\" }],\n  [\"s\", { second: \"numeric\" }],\n  [\"Z\", { timeZoneName: \"short\" }],\n]\n\n/**\n * 24 hour click format patterns.\n */\nexport const clock24: FormatPattern[] = [\n  [\"HH\", { hour: \"2-digit\" }],\n  [\"H\", { hour: \"numeric\" }],\n]\n\n/**\n * 12 hour format patterns.\n */\nexport const clock12: FormatPattern[] = [\n  [\"hh\", { hour: \"2-digit\" }],\n  [\"h\", { hour: \"numeric\" }],\n  [\"a\", { dayPeriod: \"narrow\" }],\n  [\"A\", { dayPeriod: \"narrow\" }],\n]\n\n/**\n * Tokens that have a fixed length.\n */\nexport const fixedLength = {\n  DD: 2,\n  HH: 2,\n  MM: 2,\n  YY: 2,\n  YYYY: 4,\n  hh: 2,\n  mm: 2,\n  ss: 2,\n}\n\n/**\n * token Z can have variable length depending on the actual value, so it's\n */\nexport function fixedLengthByOffset(offsetString: string): number {\n  // starts with [+-]xx:xx\n  if (/^[+-]\\d{2}:\\d{2}/.test(offsetString)) {\n    return 6\n  }\n\n  // starts with [+-]xxxx\n  if (/^[+-]\\d{4}/.test(offsetString)) {\n    return 5\n  }\n\n  throw new Error(\"Invalid offset format\")\n}\n\n/**\n * Tokens that are genitive — in that they can have \"possession\" when used in\n * a date phrase, \"March’s 4th day\" (but not in english).\n *\n * When computing a range for these, the range can be either genitive or not.\n * The same is true for parsing dates containing these tokens.\n */\nexport const genitiveTokens = [\"MMMM\", \"MMM\", \"dddd\", \"ddd\"]\n\n/**\n * A map of FormatPattern tuples to their respective token.\n */\nexport const tokens = /* @__PURE__ */ new Map(\n  /* @__PURE__ */ [...clockAgnostic, ...clock24, ...clock12].map((format) => {\n    return [format[0], format]\n  })\n)\n\n/**\n * A map of locale’s am/pm.\n */\nexport const dayPeriodMap: Map<string, { am?: string; pm?: string }> = new Map()\n\n/**\n * An array of all available date styles.\n */\nexport const styles: ReadonlyArray<FormatStyle> = [\n  \"full\",\n  \"long\",\n  \"medium\",\n  \"short\",\n]\n\n/**\n * Creates a leading zero string of 2 digits.\n * @param n - A number.\n */\nexport const two = (n: number) => String(n).padStart(2, \"0\")\n/**\n * Creates a leading zero string of 4 digits.\n * @param n - A number.\n */\nexport const four = (n: number) => String(n).padStart(2, \"0\")\n\n/**\n * Normalizes a given part to NFKC.\n * @param part - The part to normalize.\n */\nexport function normStr(\n  part: Intl.DateTimeFormatPart\n): Intl.DateTimeFormatPart {\n  if (part.type === \"literal\") {\n    part.value = part.value.normalize(\"NFKC\")\n  }\n  return part\n}\n\n/**\n * Returns the parts filled with pertinent values.\n * @param inputDate - The date to fill parts for\n * @param parts - An array of parts to fill\n * @param locale - The locale to fill with.\n * @param genitive - Whether to use genitive tokens values or not.\n * @param offset - The explicit offset to fill with (ignores the date’s true offset).\n */\nexport function fill(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false,\n  offset: string | null = null\n): FilledPart[] {\n  const partMap = createPartMap(inputDate, parts, locale, genitive)\n  const d = date(inputDate)\n\n  /**\n   * Not all values get returned \"properly\" as our tokens would suggest. For\n   * example, at times Intl returns leading zeros when it shouldn't. This fn\n   * is used to clean up those irregular values.\n   * @param param - Part\n   */\n  function value({ partName, partValue, token }: Part) {\n    if (partName === \"literal\") return partValue\n    const value = partMap[partName]\n    if (partName === \"hour\" && token === \"H\") {\n      return value.replace(/^0/, \"\") || \"0\"\n    }\n    if ([\"mm\", \"ss\", \"MM\"].includes(token) && value.length === 1) {\n      // Some tokens are supposed to have leading zeros, but Intl doesn't\n      // always return them, depending on the locale and the format.\n      return `0${value}`\n    }\n    if (partName === \"dayPeriod\") {\n      const p = ap(d.getUTCHours() < 12 ? \"am\" : \"pm\", locale)\n      return token === \"A\" ? p.toUpperCase() : p.toLowerCase()\n    }\n    if (partName === \"timeZoneName\") {\n      return offset ?? minsToOffset(-1 * d.getTimezoneOffset())\n    }\n    return value\n  }\n\n  return parts.map((part): FilledPart => {\n    return {\n      ...part,\n      value: value(part),\n    }\n  })\n}\n\n/**\n * Creates a map of part names to their respective values.\n * @param inputDate - The date to format\n * @param parts - The individual parts the need to be formatted.\n * @param locale - The locale to format the parts with.\n * @param genitive - Whether to use genitive tokens values or not.\n */\nfunction createPartMap(\n  inputDate: DateInput,\n  parts: Part[],\n  locale: string,\n  genitive = false\n): Record<keyof Intl.DateTimeFormatPartTypesRegistry, string> {\n  const d = date(inputDate)\n  const hour12 = parts.filter((part) => part.hour12)\n  const hour24 = parts.filter((part) => !part.hour12)\n  const valueParts: Intl.DateTimeFormatPart[] = []\n  const genitiveParts: Part[] = []\n\n  function addValues(requestedParts: Part[], hour12 = false) {\n    const preciseLocale = `${locale}-u-hc-${hour12 ? \"h12\" : \"h23\"}`\n    valueParts.push(\n      ...new Intl.DateTimeFormat(\n        preciseLocale,\n        requestedParts.reduce(\n          (options, part) => {\n            if (part.partName === \"literal\") return options\n            // Side effect! Genitive parts get shoved into a separate array.\n            if (genitive && genitiveTokens.includes(part.token)) {\n              genitiveParts.push(part)\n            }\n            return Object.assign(options, part.option)\n          },\n          { timeZone: \"UTC\" } as Intl.DateTimeFormatOptions\n        )\n      )\n        .formatToParts(d)\n        .map(normStr)\n    )\n    if (genitive && genitiveParts.length) {\n      for (const part of genitiveParts) {\n        let formattedParts: Intl.DateTimeFormatPart[] = []\n        switch (part.token) {\n          case \"MMMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"long\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n          case \"MMM\":\n            formattedParts = new Intl.DateTimeFormat(preciseLocale, {\n              dateStyle: \"medium\",\n              timeZone: \"UTC\",\n            })\n              .formatToParts(d)\n              .map(normStr)\n            break\n        }\n        const genitiveFormattedPart = formattedParts.find(\n          (p) => p.type === part.partName\n        )\n        const index = valueParts.findIndex((p) => p.type === part.partName)\n        if (genitiveFormattedPart && index > -1) {\n          valueParts[index] = genitiveFormattedPart\n        }\n      }\n    }\n  }\n\n  if (hour12.length) addValues(hour12, true)\n  if (hour24.length) addValues(hour24)\n\n  return valueParts.reduce((map, part) => {\n    map[part.type] = part.value\n    return map\n  }, {} as Record<keyof Intl.DateTimeFormatPartTypesRegistry, string>)\n}\n\n/**\n * Converts minutes (300) to an ISO8601 compatible offset (+0400).\n * @param timeDiffInMins - The difference in minutes between two timezones.\n * @returns\n */\nexport function minsToOffset(timeDiffInMins: number): string {\n  const hours = String(Math.floor(Math.abs(timeDiffInMins / 60))).padStart(\n    2,\n    \"0\"\n  )\n  const mins = String(Math.abs(timeDiffInMins % 60)).padStart(2, \"0\")\n  const sign = timeDiffInMins < 0 ? \"-\" : \"+\"\n  return `${sign}${hours}${mins}`\n}\n\n/**\n * Converts an offset (-0500) to minutes (-300).\n * @param offset - The offset to convert to minutes.\n */\nexport function offsetToMins(offset: string): number {\n  validOffset(offset)\n  const [_, sign, hours, mins] = offset.match(/([+-])([0-3][0-9])([0-6][0-9])/)!\n  const offsetInMins = Number(hours) * 60 + Number(mins)\n  return sign === \"+\" ? offsetInMins : -offsetInMins\n}\n\n/**\n * Validates that an offset is valid according to the format:\n * [+-]HHmm or [+-]HH:mm\n * @param offset - The offset to validate.\n */\nexport function validOffset(offset: string) {\n  const valid = /^([+-])[0-3][0-9]:?[0-6][0-9]$/.test(offset)\n  if (!valid) throw new Error(`Invalid offset: ${offset}`)\n  return offset\n}\n\n/**\n * Given a string of tokens, escape any characters that are tokens.\n * @param str - The string to escape tokens in.\n * @returns The escaped string.\n */\nexport function escapeTokens(str: string): string {\n  return clockAgnostic\n    .concat(clock24)\n    .concat(clock12)\n    .sort((a, b) => (a[0].length > b[0].length ? 1 : -1))\n    .reduce((target, part) => {\n      return target.replace(part[0], `\\\\${part[0]}`)\n    }, str)\n}\n\n/**\n * Checks if a given part should have a numeric value.\n * @param part - A part to check\n */\nexport function isNumeric(part: Part) {\n  return [\"numeric\", \"2-digit\"].includes(part.partValue)\n}\n\n/**\n * Validates that an array of Parts can be parsed.\n * @param parts - Parts to validate for parsing ability.\n */\nexport function validate(parts: Part[]): Part[] | never {\n  let lastPart: Part | undefined = undefined\n  for (const part of parts) {\n    if (part.partName === \"literal\" && !isNaN(parseFloat(part.partValue))) {\n      throw new Error(`Numbers in format (${part.partValue}).`)\n    }\n    if (\n      lastPart &&\n      lastPart.partName !== \"literal\" &&\n      part.partName !== \"literal\"\n    ) {\n      if (\n        !(lastPart.token in fixedLength) &&\n        !(part.token in fixedLength) &&\n        !(isNumeric(lastPart) && part.token.toLowerCase() === \"a\")\n      ) {\n        throw new Error(\n          `Illegal adjacent tokens (${lastPart.token}, ${part.token})`\n        )\n      }\n    }\n    lastPart = part\n  }\n  return parts\n}\n"]}